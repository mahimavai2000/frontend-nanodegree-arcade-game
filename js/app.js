var lives=3; 
var score=0;
var gemScore=0;           //When Gems collion occurs gemScore will get increase
//var gemScoreState=false;
var level=1;
var livesState=true;
var allGems = [];  //GemsArray
//Gems Values
var values = {
    gem_Height : 20,    
    gem_Width : 20,       
    gem_X : [0, 100, 200, 300, 400, 500, 600],    
    gem_Y : [160, 230, 280, 310,190,200],
    };
 
// Enemies our player must avoid
var Enemy = function(x,y,speed) {
    // Variables applied to each of our instances go here,
    // we've provided one for you to get started

    // The image/sprite for our enemies, this uses
    // a helper we've provided to easily load images
      this.sprite = 'images/enemy-bug.png';
      this.x=x;
      this.y=y;
      this.speed=speed;
};

// Update the enemy's position, required method for game
// Parameter: dt, a time delta between ticks
Enemy.prototype.update = function(dt,player) {
    // You should multiply any movement by the dt parameter
    // which will ensure the game runs at the same speed for
    // all computers.
     // Update all the enemies  
    this.x = this.x+(this.speed * dt);
    if (this.x > 480){
        this.x = 0;
      }
      return this.x;
};

// Draw the enemy on the screen, required method for game
Enemy.prototype.render = function() {
    ctx.drawImage(Resources.get(this.sprite), this.x, this.y);
};

/* Returns a random integer. 
 * Accepts two arguments, a minimum and maximum number.
 */
function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}

//Writing Gem class to display 2 gems randomly in each level increases
var Gem = function(positionX, positionY) {
    // Include the blue, green and orange gem images in an array
    var gemArray = ['Gem-Blue.png', 'Gem-Green.png', 'Gem-Orange.png','Star.png'];
    // Set a random gem image from the gemArray
    this.sprite = 'images/' + gemArray[getRandomInt(0,2)];
    // Set the gem's height
    this.height = values.gem_Height;
    // Set the gem's width
    this.width = values.gem_Width;
    // Set a the x position of the gem
    this.x = positionX;
    // Set a the y position of the gem
    this.y = positionY;
    this.gemsArray = [];
};
/* Draw the Gem on the canvas
 * The gem's x and y positions are determined by random positions
 * generated by from the the POSITION_X and POSITION_Y contstant arrays.
 */
Gem.prototype.render = function() {
    ctx.drawImage(Resources.get(this.sprite), this.x, this.y);
};
/*This method accepts an argument to determine the number of 
 gems to gemsList and push into the allGems array.*/
 
Gem.prototype.gemsList = function(number) {

    for(var i = 0; i < number; i++) {
      // Call the getRandomInt function and set the gems x position on the canvas.
      var positionX = getRandomInt(0, 6);
      // Call the getRandomInt function and set the gems y position on the canvas.
      var positionY = getRandomInt(0, 3);
      // Instatiate a new gem object.
      this.gemsArray[allGems.length] = new Gem(values.gem_X[positionX], values.gem_Y[positionY]);
      // Push the new gem into the allGems array.
      allGems.push(this.gemsArray[allGems.length]);
    }

};
/* Reset Gems
 * Clear all gems from the canvas
 */
Gem.prototype.reset = function() {
     var gemsCount = allGems.length;
     for(i = 0; i < gemsCount; i++) {
      allGems.splice(i, allGems.length);
     }
};

// Instantiate a new Gem object
var gem = new Gem();

// Now write your own player class
var Player = function(x,y) {
    // Variables applied to each of our instances go here,
    // we've provided one for you to get started
    // The image/sprite for our enemies, this uses
    // a helper we've provided to easily load images
      this.sprite = 'images/char-pink-girl.png';
      this.x=x;
      this.y=y;           
};

// This class requires an update(), render() and
// a handleInput() method.
Player.prototype.update = function(dt) {
    // You should multiply any movement by the dt parameter
    // which will ensure the game runs at the same speed for
    // all computers.
     this.checkCollision();     
     this.level();
     this.score();     
};

Player.prototype.checkPlayerBounds = function () {
    // Check bounds for x axix
    if (this.x < 0 || this.x > 600) {
    if(this.x < 0) {
        this.x = 0;
    }
     else{
            this.x = 600;           
        }
    }
    // Check bounds for x axix
    if (this.y < 0 || this.y > 520) {
    if(this.y < 0) {
        this.y = 0;
    }
   else{
            this.y = 480;            
        }
    }
}

Player.prototype.render = function() {
    ctx.drawImage(Resources.get(this.sprite), this.x, this.y);
};

Player.prototype.handleInput = function(direction) {
    // You should multiply any movement by the dt parameter
    // which will ensure the game runs at the same speed for
    // all computers.

    switch(direction){
        case "left":
            this.x -=50;         
            break;
        case "right":
            this.x +=50;          
            break;
        case "up":
            this.y -=50;      
            break;
        case "down":
            this.y +=50;        
            break;
    }
};

//Reset the player state,Lives and scrore
Player.prototype.Reset= function () {
    this.x=300;
    this.y=480; 
    document.getElementsByClassName('lives')[0].innerHTML = 'Lives: ' + lives;     
};

//Open game over window if lives is equal to 0 and reset the player Lives and scrore
Player.prototype.gameOver= function () {
    if(lives===0) {
    livesState = false;
    document.getElementById('game-over').style.display = 'block';
    document.getElementById('game-over-overlay').style.display = 'block';
    }

    //Reset the Lives,Score and Level when 3 lives completes
    if(livesState===false) {
    lives=3;
    score=0;
    level=1;
    livesState=true;
    document.getElementsByClassName('lives')[0].innerHTML = 'Lives: ' + lives;
    document.getElementsByClassName('score')[0].innerHTML = 'Score: ' + score;
    document.getElementsByClassName('level')[0].innerHTML = 'Level: ' + level;
    gem.reset();
    }

};

//Check Collision
Player.prototype.checkCollision = function() {     
  for (var i=0; i< allEnemies.length; i++) {    
      if (this.x < allEnemies[i].x + 75 &&
        this.x + 65 > allEnemies[i].x &&
        this.y < allEnemies[i].y + 50 &&
        70 + this.y > allEnemies[i].y) {        
        lives--;
      this.Reset(); 
      this.gameOver();     
    }
}

//Collision with Gems
for (var i=0; i< allGems.length; i++) {    
      if (this.x < allGems[i].x + 75 &&
        this.x + 65 > allGems[i].x &&
        this.y < allGems[i].y + 50 &&
        70 + this.y > allGems[i].y) {        
        gemScore=gemScore+300;
        console.log(gemScore);       
    }
}
};

//Level method to increase the next levels
Player.prototype.level= function() {     
       
      if (this.y===0) {        
        level=level+1;
        score+=500;
        //document.getElementsByClassName('score')[0].innerHTML = 'Score: ' + score;
        //document.getElementsByClassName('level')[0].innerHTML = 'Level: ' + level;
        this.Reset();
        gem.reset();
        gem.gemsList(2);

      }
 };

 //Display score and Levels
Player.prototype.score= function() {     
       score=score+gemScore;
        document.getElementsByClassName('score')[0].innerHTML = 'Score: ' + score;
        document.getElementsByClassName('level')[0].innerHTML = 'Level: ' + level;
           
 };

// Now instantiate your objects.
var allEnemies = [];
var enemy1= new Enemy(10,70,300);
var enemy2= new Enemy(10,150,170);
var enemy3= new Enemy(10,230,220);

// Place all enemy objects in an array called allEnemies
//var allEnemies = [enemy1, enemy2, enemy3];
allEnemies.push(enemy1, enemy2, enemy3);

// Place the player object in a variable called player
var player= new Player(300,480);


// This listens for key presses and sends the keys to your
// Player.handleInput() method. You don't need to modify this.
document.addEventListener('keyup', function(e) {
    var allowedKeys = {
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down'
    };
    player.handleInput(allowedKeys[e.keyCode]);
    player.checkPlayerBounds();
});
